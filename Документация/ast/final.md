# Table of Contents

* [Оптимизация операции умножения на единицу](#оптимизация-операции-умножения-на-единицу)
* [Оптимизация операции умножения на ноль](#оптимизация-операции-умножения-на-ноль)
* [Оптимизация перемножения констант](#оптимизация-перемножения-констант)
* [Оптимизация суммирования с нулем](#оптимизация-суммирования-с-нулем)
* [Оптимизация вычитания собственного значения](#оптимизация-вычитания-собственного-значения)
* [Оптимизация операции меньше](#оптимизация-операции-меньше)
* [Оптимизация операции сравнения равно](#оптимизация-операции-сравнения-равно)
* [Оптимизация операций сравнения с собой](#оптимизация-операций-сравнения-с-собой)
* [Оптимизация операций больше, не равно](#оптимизация-операций-больше,-не-равно)
* [Оптимизация присваивания собственного значения](#оптимизация-присваивания-собственного-значения)
* [Оптимизация if true](#оптимизация-if-true)
* [Оптимизация if false](#оптимизация-if-false)
* [Оптимизация if ex null else null](#оптимизация-if-ex-null-else-null)
* [Оптимизация while false](#оптимизация-while-false)
* [Удаление всех null](#удаление-всех-null)
* [Оптимизация вложенных блоков](#оптимизация-вложенных-блоков)


# Оптимизация операции умножения на единицу

### Команда Roll

#### Постановка задачи
Выполнить замену выражений вида 1 \* ex, ex \* 1, ex / 1 на ex для AST.

#### Зависимости задач в графе задач

Задача зависит от:
* Построение AST

#### Теория
Оптимизации на AST являются достаточно простыми и в то же время важными, так как позволяют убирать целые блоки кода или выражения еще до генерации кода. Данный тип оптимизаций выполняется с помощью шаблона проектирования Visitor, который позволяет изменять однотипные сущности. В нашем случае это узлы AST. Очевидно, что выражения 1 \* ex, ex \* 1, ex / 1 следует заменить на ex.

#### Особенности реализации
Для использования данной оптимизации необходимо:
1. Подключить пространство имен SimpleLang.Visitors;
2. Построить AST
3. Проставить ссылки на родителей для каждого узла
4. Создать визитор OptMulDivOneVisitor и применить его к AST

Ниже представлен код использования данной оптимизации:
```csharp
// синтаксическое дерево уже построено
	var r = parser.root;	// корень AST
	r.Visit(new FillParentVisitor());	// установка ссылок на родителей на AST
	r.Visit(new OptMulDivOneVisitor());	// выполнение текущей оптимизации
```
Далее AST используется для генерации трехадресного, а затем IL кода.

#### Тесты
```
Исходный код до оптимизации:
{
    int a,b;
    a = 1;
    while (false)
    {
        while ((((a * 1) + (b / 1)) + (1 * a)))
        {

        }
    }
    a = 2;
}
После оптимизации:
{
    int a,b;
    a = 1;

    a = 2;
}
```
# Оптимизация операции умножения на ноль

### Команда Roslyn

#### Постановка задачи
Требуется найти в AST-дереве выражения, в которых происходит умножение некоторого подвыражения на константное число 0 и произвести замену всего выражения на число 0.

#### Зависимости задач в графе задач
Задача зависит от:
* генерация AST-дерева;
* заполнение связей типа "предок-потомок".

#### Теория
В исходном коде программы в некоторых случаях можно встретить явное умножение алгебраического выражения на число 0. В данному случае можно произвести оптимизацию кода на этапе компиляции, заменив все подвыражение на константное значение 0. К случаям, когда можно применить оптимизацию, можно отнести следующие:
* *b\*0*
* *0\*b*

Подобные выражения можно оптимизировать, если при компиляции исходного кода программы заменить данное выражение на число 0. Подобная оптимизация позволит сделать вычисление программы более быстрым, поскольку потребуется меньше памяти для вычисления программы, поскольку некоторые переменные перестанут быть необходимыми, и операций работы с оперативной памятью.

#### Особенности реализации
При использовании программного кода, позволяющего произвести оптимизацию выражений, внутри которых происходит умножение на 0, требуется произвести построение AST-дерева для исходного кода программы, написанном на реализованном языке программирования, и выделить для построенного дерева связи типа "предок-потомок". К полученному дереву следует применить визитор SimpleLang.Visitors.Opt2Visitor. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать AST-дерево;
2) с помощью визитора SimpleLang.Visitors.FillParentVisitor заполнить связи между узлами дерева типа "предок-потомок";
3) создать объект типа SimpleLang.Visitors.Opt2Visitor;
4) для полученного дерева вызвать функцию Visit с объектом Opt2Visitor, созданном на 3-ем этапе, поданным как аргумент функции.
```csharp
using SimpleLang.Visitors;
...
FillParentVisitor pvisit = new FillParentVisitor();
tree.Visit(pvisit);
Opt2Visitor zvisit = new Opt2Visitor();
tree.Visit(zvisit);
```
В данном коде подразумевается, что переменная *tree* содержит в себе AST-дерево программы.


#### Тесты
Для исходного кода 
```csharp
{
	int b;
	b = b * (1+2+3+123+321) * (654/332*0) + 123;
}
```

После использования оптимизации умножения на 0 в AST-дереве получается следующий код:
```csharp
{
	int b;
	b = b * (1+2+3+123+321) * (0) + 123;
}
```
Если использовать данную оптимизацию каскадно, то можно получить следующий код:
```csharp
{
	int b;
	b = 0 + 123;
}
```

# Оптимизация перемножения констант

### Команда Komanda

#### Постановка задачи
Задача состояла в замене умножения констант на их произведение

#### Зависимости в графе задач
Данная задача не зависит от других задач в графе задач и не порождает новых зависимостей

#### Теория
Очевидно, что замена выражения вида const*const на значение этого произведения является эквивалентным преобразованием

#### Особенности реализации
```csharp
    namespace SimpleLang.Visitors
    {
        class MultiplicationComputeVisitor : ChangeVisitor
        {
            public override void VisitBinOpNode(BinOpNode binop)
            {
                if (binop.Left is ExprNode el)
                    el.Visit(this);
                if (binop.Right is ExprNode er)
                    er.Visit(this);
                if (binop.Left is IntNumNode l && binop.Right is IntNumNode r && binop.Op == "*")
                    ReplaceExpr(binop, new IntNumNode(l.Num * r.Num));
                else
                    base.VisitBinOpNode(binop);
            }
        }
    }
```
Для каждого выражения вызываем визитор рекурсивно и при встрече умножения двух констант заменяем их на произведение

#### Тесты
исходный код:
```csharp
    int a;
    a = 2 * 3;
```
результат:
```csharp
    int a;
    a = 6;
```
# Оптимизация суммирования с нулем

### Команда South Park

#### Постановка задачи

Задача состояла в реализации оптимизации AST-дерева вида 0+expr

#### Зависимости задач в графе задач

Данная задача не зависит от других задач в графе задач и не порождает новых зависимостей.

#### Теория
При возникновении узла _BinOpNode_, один из аргументов которого является нулём, необходимо удалить ноль, а также осуществить обход дерева внутрь ненулевого выражения.

#### Особенности реализации

```csharp
    class PlusNonZero : AutoApplyVisitorInterface
    {
        public override void VisitBinOpNode(BinOpNode binop)
        {
            if (binop.Left is IntNumNode && (binop.Left as IntNumNode).Num == 0 &&
            binop.Op[0] == '+')
            {
                binop.Right.Visit(this); 
                ReplaceExpr(binop, binop.Right); 
            }
            else
            {
                if (binop.Right is IntNumNode && (binop.Right as IntNumNode).Num == 0 &&
            binop.Op[0] == '+')
                {
                    binop.Left.Visit(this);
                    ReplaceExpr(binop, binop.Left);
                }
                else
                {
                    base.VisitBinOpNode(binop);
                }
                
            }
        }
    }
```
Класс _PlusNonZero_ является визитором и реализует интерфейс _AutoApplyVisitorInterface_. При посещении узла проверяется, является ли левый оператор целым нулевым числом, а операция-сложением. Если да, то происходит обход правого оператора и замена всего узла на правый оператор. Иначе происходит та же проверка на правый оператор. Если нужной ситуации не нашлось, продолжается обход дерева в обычном режиме.

#### Тесты
Пример входной программы:
```
{
    real b;
    int c;
    b=3.14+0;
    c = 0;
}
```
Пример программы после применения оптимизации:
```
{
    var b;
    var c;
    b = 3.14;
    c = 0;
}
```



# Оптимизация вычитания собственного значения

### Команда Nvidia

#### Постановка задачи
Требуется найти в AST-дереве выражения разности, оба операнда которых являются одной переменной на этапе компиляции и заменить их на константу `0`.

#### Зависимости задач в графе задач
Данная задача не зависит от других задач в графе задач и не порождает новых зависимостей.

#### Теория
В исходном коде программы возникают случаи, когда аргументы оператора разности равны. Такие операторы необходимо заменить на 0.

#### Особенности реализации
```
public class OptSimilarDifference : AutoApplyVisitorInterface
    {
        public override void VisitBinOpNode(BinOpNode binop)
        {
            if ((binop.Left is IdNode) && (binop.Right is IdNode) &&
                String.Equals((binop.Left as IdNode).Name, (binop.Right as IdNode).Name) &&
                (binop.Op == "-"))
            {
                ReplaceExpr(binop, new IntNumNode(0));
            }
            else
            {
                base.VisitBinOpNode(binop); // Обойти потомков обычным образом
            }
        }
        public override void VisitIfNode(IfNode ifn)
        {
            ifn.Cond.Visit(this);
        }
        public override void VisitWhileNode(WhileNode w)
        {
            w.Expr.Visit(this);
        }

        public override string ToString()
        {
            return "";
        }
    }
```
Был реализован класс `OptSimilarDifference`, который переопределяет процедуру `VisitBinOpNode`. Оптимизация происходит в случае, если оба операнда являются `IdNode`, их имена равны и бинарная операция - это разность.

#### Тесты
Программа до применения оптимизации:
```
```
Программа после применения оптимизации:
```
```
# Оптимизация операции меньше

### Команда GreatBean

#### Постановка задачи
Требуется найти в AST-дереве операторы сравнения, оба операнда которого являются числами на этапе компиляции и заменить их на логическое утверждение этих операторов.

#### Зависимости задач в графе задач
Задача зависит от:
* генерация AST-дерева;
* заполнение связей типа "предок-потомок".

#### Теория
В исходном коде программы зачастую появляются случаи, когда уже на этапе компиляции ясно, какие значения приняли те или иные перменные, являющиейся операндами в оператора сравнения. Преждевременая замена таких операторов на логические выражения, соответствующие смыслу этих опраторов может заметно ускорить программу на этапе выполнения.


#### Особенности реализации
При использовании программного кода, позволяющего произвести оптимизацию операторов сравнения, требуется произвести построение AST-дерева для исходного кода программы, написанном на реализованном языке программирования, и выделить для построенного дерева связи типа "предок-потомок".
К полученному дереву следует применить визитор SimpleLang.Visitors.LessOptVisitor. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать AST-дерево;
2) с помощью визитора SimpleLang.Visitors.FillParentVisitor заполнить связи между узлами дерева типа "предок-потомок";
3) создать объект типа SimpleLang.Visitors.LessOptVisitor;
4) для полученного дерева вызвать функцию Visit с объектом LessOptVisitor, созданном на 3-ем этапе, поданным как аргумент функции.

Для решения этой задачи был реализован класс LessOptVisitor, который переопределяет класс VisitLogicOpNode. Стоит отметить, что перед заменой оператора сравнения на его логическое значение необходимо заранее обойти каждого из операндов для рекурсивной проверки их на возможность такой-же оптимизации.
Важно понимать, что оптимизации просиходит только в случае принадлежности обоих операндов численному типу.
```csharp
public class LessOptVisitor : ChangeVisitor
{
    public override void VisitLogicOpNode(LogicOpNode lop)
    {
        if (lop.Left is ExprNode)
            lop.Left.Visit(this); // Вначале сделать то же в левом поддереве

        if (lop.Right is ExprNode)
            lop.Right.Visit(this); // Затем в правом поддереве

        if (lop.Left is IntNumNode l && lop.Right is IntNumNode r
            && (lop.Operation == ">" || lop.Operation == "<"))
        {
            //Посчитаем сам знак
            bool nbool = lop.Operation == ">" ? l.Num > r.Num : l.Num < r.Num;
            //Проверим, что выражение не является условиев if
            if (lop.Parent is IfNode ifn)
                ifn.Cond = new BooleanNode(nbool);
            //Проверим, что выражение не является условиев while
            else if (lop.Parent is WhileNode w)
                w.Expr = new BooleanNode(nbool);
            else
                ReplaceExpr(lop, new BooleanNode(nbool));
        }
        else // Если оптимизаций нет, то
        {
            base.VisitLogicOpNode(lop); // Обойти потомков обычным образом
        }
    }

}
```


#### Тесты
Из исходной программы вида
```csharp
{
	bool w;
	w = (1 > 2) && (4 < 77);
}
```

Мы получаем
```csharp
{
    var w;
    w = (false && true);
}
```

# Оптимизация операции сравнения равно

### Команда Intel

#### Постановка задачи

Требуется найти в AST-дереве операторы сравнения, оба операнда которого являются числами на этапе компиляции и заменить их на логическое утверждение этих операторов.


#### Зависимости задач в графе задач

Данная задача не зависит от других задач в графе задач и не порождает новых зависимостей.


#### Теория

В исходном коде программы зачастую появляются случаи, когда уже на этапе компиляции ясно, какие значения приняли те или иные переменные, являющейся операндами в оператора сравнения. Преждевременная замена таких операторов на логические выражения, соответствующие смыслу этих операторов может заметно ускорить программу на этапе выполнения.


#### Особенности реализации

```
public override void VisitLogicOpNode (LogicOpNode lop) 
        {
            if (lop.Left is ExprNode)
                lop.Left.Visit(this); 

            if (lop.Right is ExprNode)
                lop.Right.Visit(this);

            if (lop.Left is IntNumNode l && lop.Right is IntNumNode r && (lop.Operation == "==")) {
                bool nbool = l.Num == r.Num;
                if (lop.Parent is IfNode ifn) {
                    ifn.Cond = new BooleanNode(nbool);
                    SetApply();
                } else
                    if (lop.Parent is WhileNode w) {
                    w.Expr = new BooleanNode(nbool);
                    SetApply();
                    } else
                        ReplaceExpr(lop, new BooleanNode(nbool));
            } else {
                base.VisitLogicOpNode(lop);
            }
        }

```

Была переопределена функция VisitLogicOpNode. Стоит отметить, что перед заменой оператора сравнения на его логическое значение необходимо заранее обойти каждого из операндов для рекурсивной проверки их на возможность такой-же оптимизации. Оптимизации происходит только в случае принадлежности обоих операндов численному типу.



#### Тесты

Программа до применения оптимизации:
```
{
	bool w;
	w = (1 == 2) && (4 == 4);
}
```

Программа после применения оптимизации:
```
{
    var w;
    w = (false && true);
}
```
# Оптимизация операций сравнения с собой
 
### Команда qwerty

#### Постановка задачи

Задача состояла в реализации оптимизации по AST-дереву выражений вида: ``` a==a``` и ``` a>=a```.

#### Зависимости задач в графе задач

Данная задача не зависит от других задач в графе задач и не порождает новых зависимостей.

#### Теория

Данная оптимизация заключается в том, чтобы заменять любое выражение вида ``` a==a``` или ``` a>=a``` на значение ```true```, так как эти выражения всегда дают истину.

#### Особенности реализации

```csharp
class OptVisitor_8 : ChangeVisitor2  
{  
    public override void VisitBinOpNode(BinOpNode binop)  
    {  
        if ((binop.Left is IdNode) && (binop.Right is IdNode) &&  
            (binop.Left as IdNode).Name == (binop.Right as IdNode).Name &&  
            (binop.Op == "==" || binop.Op == ">="))  
        {  
            if (binop.Parent is IfNode ifn)  
                ifn.Cond = new BooleanNode(true);  
            else if (binop.Parent is WhileNode w)  
                w.Expr = new BooleanNode(true);  
            else  
                ReplaceExpr2(binop, new BooleanNode(true));  
        }  
        else if ((binop.Left is ExprNode) && (binop.Right is ExprNode) &&  
                 (binop.Left.ToString() == binop.Right.ToString()) &&  
                 (binop.Op == "==" || binop.Op == ">="))  
        {  
            if (binop.Parent is IfNode ifn)  
                ifn.Cond = new BooleanNode(true);  
            else if (binop.Parent is WhileNode w)  
                w.Expr = new BooleanNode(true);  
            else  
                ReplaceExpr2(binop, new BooleanNode(true));  
        }  
        else    
            base.VisitBinOpNode(binop); // Обойти потомков обычным образом  
    }  

    public override void VisitIfNode(IfNode ifn)  
    {  
        ifn.Cond.Visit(this);  
    }  

    public override void VisitWhileNode(WhileNode w)  
    {  
        w.Expr.Visit(this);  
    }  
}
```
Класс _OptVisitor_8_ перегружает метод _VisitBinOpNode_, который при посещении узла AST-дерева, содержащего бинарное выражение типов: ```a==a``` или ```a>=a```, заменяет это выражение на        ```BooleanNode(true)```  с помощью метода _ReplaceExpr2_.

#### Тесты
Код до применения оптимизации:
```
if(a==a)
	x = x * 10;
```

Код после применения оптимизации:
```
if(true)
	x = x * 10;
```

# Оптимизация операций больше, не равно

### Команда Komanda

#### Постановка задачи
Задача состояла в замене логических выражений x != x, x > x на false

#### Зависимости в графе задач

Данная задача не зависит от других задач в графе задач и не порождает новых зависимостей

#### Теория

Логические выражения x != x и x > x равны false при любых значениях x, поэтому можно выполнять замену.

#### Особенности реализации

    using ProgramTree;
    using SimpleLang.Visitors;
    
    namespace SimpleLang.AstOptimisations
    {
        public class FalseExprMoreAndNonEqualVisitor : AutoApplyVisitorInterface
        {
            public override void VisitLogicOpNode(LogicOpNode lop)
            {
                if ((lop.Operation == ">" || lop.Operation == "!=") && lop.Right.ToString() == lop.Left.ToString())
                {
                    ReplaceExpr(lop, new BooleanNode(false));
                }
            }
        }
    }
    

Для всех логических операций проверяем, чтобы бинарная операция была = ">" или "!=" и левый и правый операнды были равны  

#### Тесты

исходный код:

    int a;
	bool b;
    b = a > a;
	b = a != a;

результат:

    int a;
    bool b;
    b = false;
    b = false;
# Оптимизация присваивания собственного значения

### Команда BOOM

#### Постановка задачи
Требуется заменить в AST-дереве присваивания вида a = a на null.

#### Зависимости задач в графе задач
Задача зависит от:
* генерация AST-дерева;
* заполнение связей типа "предок-потомок".

#### Теория
В исходном коде программы иногда можно встретить присваивания переменной самой себе. По сути после выполнения такого кода ничего не меняется, значит от такого кода можно и нужно избавляться. На этапе компиляции можно выявить такие дефекты и произвести оптимизацию.

#### Особенности реализации
При использовании программного кода, позволяющего произвести оптимизацию устранения выражений вида a = a, требуется произвести построение AST-дерева для исходного кода программы, написанном на реализованном языке программирования, и выделить для построенного дерева связи типа "предок-потомок". К полученному дереву следует применить визитор SimpleLang.Visitors.AssignVisitor. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать AST-дерево;
2) с помощью визитора SimpleLang.Visitors.FillParentVisitor заполнить связи между узлами дерева типа "предок-потомок";
3) создать объект типа SimpleLang.Visitors.AssignVisitor;
4) для полученного дерева вызвать функцию Visit с объектом AssignVisitor, созданном на 3-ем этапе, поданным как аргумент функции.

Для решения этой задачи был реализован класс AssignVisitor, который переопределяет процедуру VisitAssignNode.
```csharp
class AssignVisitor: ChangeVisitor
    {
        public override void VisitAssignNode(AssignNode a)
        {
            if ((a.Expr is IdNode) && String.Equals(a.Id.Name, (a.Expr as IdNode).Name))
            {
                ReplaceStat(a, new NullNode());
            }
            else
            {
                base.VisitAssignNode(a);
            }
        }

        public override void VisitIfNode(IfNode ifn)
        {
            ifn.Cond.Visit(this);
        }
        public override void VisitWhileNode(WhileNode w)
        {
            w.Expr.Visit(this);
        }

        public override string ToString()
        {
            return "";
        }
    }
```


#### Тесты
Из исходной программы вида
```csharp
{
    int a, b;
    int c, d;
    a = 3;
    b = a + 3;
    c = b + a + 2;
    d = c + b;
    c = c;
    b = a + 2;
    d = d;
    a = b + 1;
}

```

Мы получаем
```csharp
{
    int a, b;
    int c, d;
    a = 3;
    b = a + 3;
    c = b + a + 2;
    d = c + b;
    #NULL;
    b = a + 2;
    #NULL;
    a = b + 1;
}

```

# Оптимизация if true

### Команда Roslyn

#### Постановка задачи
Требуется найти в AST-дереве условные операторы, в условии которых используется константное значение, принимающее истинное значение, и произвести замену всего условного оператора в AST-дереве на операторы из ветки true данного оператора.

#### Зависимости задач в графе задач
Задача зависит от:
* генерация AST-дерева;
* заполнение связей типа "предок-потомок".

#### Теория
В исходном коде программы в некоторых случаях можно встретить условный оператор, в котором в явном виде в условии указано константа true. В данному случае можно произвести оптимизацию кода на этапе компиляции, заменив весь условный оператор на операторы из его ветки по условию истинности. К случаям, когда можно применить оптимизацию, можно отнести следующие:
* *if ( true ) { OperatorTrue; } else { OperatorElse; }*

Подобные условные операторы можно оптимизировать на этапе компиляции, заменив весь код данного условного оператора на операторы ветки true. В данном примере это *{ OperatorTrue; }*. Данная оптимизация позволит избавить код программы от лишних вычислений условного оператора, а также от ненужных операторов перехода, которые могут замедлить выполнение скомпилированной программы.

#### Особенности реализации
При использовании программного кода, позволяющего произвести оптимизацию условного оператора, принимающего в качестве условия истинную константу, требуется произвести построение AST-дерева для исходного кода программы, написанном на реализованном языке программирования, и выделить для построенного дерева связи типа "предок-потомок". К полученному дереву следует применить визитор SimpleLang.Visitors.Opt11Visitor. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать AST-дерево;
2) с помощью визитора SimpleLang.Visitors.FillParentVisitor заполнить связи между узлами дерева типа "предок-потомок";
3) создать объект типа SimpleLang.Visitors.Opt11Visitor;
4) для полученного дерева вызвать функцию Visit с объектом Opt11Visitor, созданном на 3-ем этапе, поданным как аргумент функции.
```csharp
using SimpleLang.Visitors;
...
FillParentVisitor pvisit = new FillParentVisitor();
tree.Visit(pvisit);
Opt11Visitor zvisit = new Opt11Visior();
tree.Visit(zvisit);
```
В данном коде подразумевается, что переменная *tree* содержит в себе AST-дерево программы.


#### Тесты
Для исходного кода 
```csharp
{
	int b;
	int a;
	a = 0;
	b = 1;
	if ( true ) {
	    int r;
	    r = a;
	    a = b;
	    b = r + a;
	} else {
	    int i;
	    for (i=1 to 100)
	        a = b * i;
	}
	println(a);
}
```

После использования оптимизации условного оператора, принимающего в качестве условия истинное значение, в AST-дереве получается следующий код:
```csharp
{
	int b;
	int a;
	a = 0;
	b = 1;
	{
	    int r;
	    r = a;
	    a = b;
	    b = r + a;
	}
	println(a);
}
```

# Оптимизация if false

### Команды GreatBean, Komanda, Intel

#### Постановка задачи
Требуется найти в AST-дереве if, в которых логическое условие ложно и произвести замену всего if на содержимое ветки else .

#### Зависимости задач в графе задач
Задача зависит от:
* генерация AST-дерева;
* заполнение связей типа "предок-потомок".

#### Теория
В исходном коде программы зачастую появляются случаи, когда условные операторы if не выполняют своего прямого назначения, и замедлют программу. Это встречается, когда в логическом условии находится переменная, значение которой известно еще на этапе компиляции. На этапе компиляции можно выявить такие неявные дефекты и произвести оптимизацию.


#### Особенности реализации
При использовании программного кода, позволяющего произвести оптимизацию условных операторов, логические условия которых равны false, требуется произвести построение AST-дерева для исходного кода программы, написанном на реализованном языке программирования, и выделить для построенного дерева связи типа "предок-потомок". К полученному дереву следует применить визитор SimpleLang.Visitors.ElseStVisitor. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать AST-дерево;
2) с помощью визитора SimpleLang.Visitors.FillParentVisitor заполнить связи между узлами дерева типа "предок-потомок";
3) создать объект типа SimpleLang.Visitors.ElseStVisitor;
4) для полученного дерева вызвать функцию Visit с объектом ElseStVisitor, созданном на 3-ем этапе, поданным как аргумент функции.

Для решения этой задачи был реализован класс ElseStVisitor, который переопределяет класс VisitIfNode. Стоит отметить, что перед заменой всего условного оператора на ветку else необходимо обойти ее на предмет этой же оптимизации для покрытия всех возможных вхождений таких условных операторов.
```csharp
class ElseStVisitor : ChangeVisitor
    {
        public override void VisitIfNode(IfNode ifn)
        {
            if (ifn.Cond is BooleanNode boolVal && !boolVal.Val)
            {
                ifn.Else.Visit(this);
                ReplaceStat(ifn, ifn.Else);
            }
        }
    }
```


#### Тесты
Из исходной программы вида
```csharp
{
  int a;
	if (false)
  {
    if (true)
    {
      a = 1;
    }
    else
    {
      a = 2;
    }
  }
  else
  {
    if (false)
    {
      a = 3;
    }
    else
    {
      a = 4;
    }
  }
}

```

Мы получаем
```csharp
{
    var a;
    {
        {
            a = 4;
        }
    }
}

```

# Оптимизация if ex null else null

### Команда qwerty

#### Постановка задачи

Задача состояла в реализации оптимизации по AST-дереву условных операторов вида: 
``` 
if(expression)
	null;
else
	null;
```
#### Зависимости задач в графе задач

Данная задача не зависит от других задач в графе задач и не порождает новых зависимостей.

#### Теория

Данная оптимизация заключается в том, чтобы заменять любой условный оператор вида
``` 
if(expression)
	null;
else
	null;
```
на выражение ``` null```, так как при любом ```expression``` в условном операторе будет получен ``` null```.
#### Особенности реализации

```csharp
class OptVisitor_13 : ChangeVisitor2  
{  
    public override void VisitBlockNode(BlockNode bl)  
    {  
        for (int i = 0; i < bl.StList.Count; i++)  
            if (bl.StList[i] is IfNode ifn)  
            {  
                var stlist1 = ifn.If as BlockNode;  
                var stlist2 = ifn.Else as BlockNode;  
                bool null1, null2;  
                null1 = null2 = false;  
                if (stlist1.StList.Count == 1 & stlist1.StList[0] is NullNode)  
                    null1 = true;  
                if (stlist2.StList.Count == 1 & stlist2.StList[0] is NullNode)  
                    null2 = true;  
  
                if (null1 && null2)  
                    bl.StList[i] = new NullNode();  
                else  
                    base.VisitIfNode(ifn);  
            }  
    }  
}
```
Класс _OptVisitor_13_ перегружает метод _VisitBlockNode_, который при посещении узла AST-дерева, являющегося узлом условного оператора вида: 
``` 
if(expression)
	null;
else
	null;
```
 заменяет этот узел на   ```NullNode()```.

##$# Тесты
Код до применения оптимизации:
```
if(a!=b)
	null;
else
	null;
```

Код после применения оптимизации:
```
null;
```

# Оптимизация while false

### Команда Roll

#### Постановка задачи
Выполнить замену выражений while (false) st; на null для AST.

#### Зависимости задач в графе задач

Задача зависит от:
* Построение AST

#### Теория
Оптимизации на AST являются достаточно простыми и в то же время важными, так как позволяют убирать целые блоки кода или выражения еще до генерации кода. Данный тип оптимизаций выполняется с помощью шаблона проектирования Visitor, который позволяет изменять однотипные сущности. В нашем случае это узлы AST. Очевидно, что в while (false) st; st - недостижимый код, подлежащий удалению.


#### Особенности реализации
Для использования данной оптимизации необходимо:
1. Подключить пространство имен SimpleLang.Visitors;
2. Построить AST
3. Проставить ссылки на родителей для каждого узла
4. Создать визитор OptWhileVisitor и применить его к AST

Ниже представлен код использования данной оптимизации:
```csharp
// синтаксическое дерево уже построено
	var r = parser.root;	// корень AST
	r.Visit(new FillParentVisitor());	// установка ссылок на родителей на AST
	r.Visit(new OptWhileVisitor());	// выполнение текущей оптимизации
```
Далее AST используется для генерации трехадресного, а затем IL кода.


#### Тесты
```
Исходный код до оптимизации
{
    var a,b;
    a = (((((1 * 1) / 2) / 1) + (a * 1)) + (1 * a));
    while (false)
    {
        while ((((a * 1) + (b / 1)) + (1 * a)))
        {

        }
    }
    a = 2;
}
После оптимизации:
{
    var a,b;
    a = (((1 / 2) + a) + a);
    while (false)
    {
        while (((a + b) + a))
        {

        }
    }
    a = 2;
}
```
# Удаление всех null

### Команда BOOM

#### Постановка задачи
Требуется исключить в AST-дереве null-операторы.

#### Зависимости задач в графе задач
Задача зависит от:
* генерация AST-дерева;
* заполнение связей типа "предок-потомок".

#### Теория
В исходном коде программы зачастую можно встретить null-операторы. Они не несут какой-либо полезной информации, следовательно от них нужно избавиться. На этапе компиляции можно выявить такие места и произвести оптимизацию.

#### Особенности реализации
При использовании программного кода, позволяющего произвести оптимизацию устранения null-операторов, требуется произвести построение AST-дерева для исходного кода программы, написанном на реализованном языке программирования, и выделить для построенного дерева связи типа "предок-потомок". К полученному дереву следует применить визитор SimpleLang.Visitors.DeleteNullVisitor. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать AST-дерево;
2) с помощью визитора SimpleLang.Visitors.FillParentVisitor заполнить связи между узлами дерева типа "предок-потомок";
3) создать объект типа SimpleLang.Visitors.DeleteNullVisitor;
4) для полученного дерева вызвать функцию Visit с объектом DeleteNullVisitor, созданном на 3-ем этапе, поданным как аргумент функции.

Для решения этой задачи был реализован класс DeleteNullVisitor, который переопределяет процедуры  VisitBlockNode и VisitIfNode.
```csharp
class DeleteNullVisitor: ChangeVisitor
   {
       public override void VisitBlockNode(BlockNode bln)
       {
           bln.StList = bln.StList.Where(x =>!(x is NullNode)).ToList();
       }
       public override void VisitIfNode(IfNode ifn)
       {
           if (ifn.Else is NullNode)
           {
               ReplaceStat(ifn, new NullNode());
           }
       }
   }
```


#### Тесты
Из исходной программы вида
```csharp
{
    int a, b, c;
    a = 3;
    #NULL;
    b = 2;
    #NULL;
    c = 1;
    #NULL;
    c = c + a;
}

```

Мы получаем
```csharp
{
    int a, b, c;
    a = 3;
    b = 2;
    c = 1;
    c = c + a;
}

```

# Оптимизация вложенных блоков

### Команда South Park

#### Постановка задачи

Задача состояла в реализации оптимизации AST-дерева следующего вида: все блоки, вложенные в блоки, сделать линейными

#### Зависимости задач в графе задач

Данная задача не зависит от других задач в графе задач и не порождает новых зависимостей.

#### Теория
Если один блок оказывается вложен в другой и при этом внутренний блок не относится ни к какому оператору, его можно линеаризовать.

#### Особенности реализации

```csharp
    class LinearizeBlocks : AutoApplyVisitorInterface
    {
        public override void VisitBlockNode(BlockNode bl)
        {
            for (int i = 0; i < bl.StList.Count; i++)
            {
                if (bl.StList[i] is BlockNode)
                {
                    BlockNode bl1= (BlockNode)bl.StList[i];

                    bl.StList.RemoveAt(i);
                    for (int j = 0; j < bl1.StList.Count; j++)
                    {
                        bl.StList.Insert(i+j, bl1.StList[j]);
                    }
                }
                bl.StList[i].Visit(this);
            }    
        }
    }
```
Класс _LinearizeBlocks_ является визитором и реализует интерфейс _AutoApplyVisitorInterface_. При посещении узла типа блок функция проходит по всем его инструкциям и, если какая-то инструкция является блоком, то это вложенный блок. Чтобы его линеаризовать, список инструкций блока сохраняется в переменную типа блок, далее алгоритм удаляет вложенный блок. После этого алгоритм заменяет удаленный вложенный блок его инструкциями. После этой процедуры обход дерева продолжается в обычном режиме.

#### Тесты
Пример входной программы:
```
{
	real b;
	int c;
	b=3.14;
	{
		c = 0;
	}	
}
```
Пример программы после применения оптимизации:
```
{
	var b;
	var c;
	b = 3.14;
	c = 0;
}
```


