# Оптимизация операции умножения на единицу !heading

### Команда Roll

#### Постановка задачи
Выполнить замену выражений вида 1 \* ex, ex \* 1, ex / 1 на ex для AST.

#### Зависимости задач в графе задач

Задача зависит от:
* Построение AST

#### Теория
Оптимизации на AST являются достаточно простыми и в то же время важными, так как позволяют убирать целые блоки кода или выражения еще до генерации кода. Данный тип оптимизаций выполняется с помощью шаблона проектирования Visitor, который позволяет изменять однотипные сущности. В нашем случае это узлы AST. Очевидно, что выражения 1 \* ex, ex \* 1, ex / 1 следует заменить на ex.

#### Особенности реализации
Для использования данной оптимизации необходимо:
1. Подключить пространство имен SimpleLang.Visitors;
2. Построить AST
3. Проставить ссылки на родителей для каждого узла
4. Создать визитор OptMulDivOneVisitor и применить его к AST

Ниже представлен код использования данной оптимизации:
```csharp
// синтаксическое дерево уже построено
	var r = parser.root;	// корень AST
	r.Visit(new FillParentVisitor());	// установка ссылок на родителей на AST
	r.Visit(new OptMulDivOneVisitor());	// выполнение текущей оптимизации
```
Далее AST используется для генерации трехадресного, а затем IL кода.

#### Тесты
```
Исходный код до оптимизации:
{
    int a,b;
    a = 1;
    while (false)
    {
        while ((((a * 1) + (b / 1)) + (1 * a)))
        {

        }
    }
    a = 2;
}
После оптимизации:
{
    int a,b;
    a = 1;

    a = 2;
}
```

[Вверх](#содержание)