# Удаление мертвых переменных !heading

### Команда Roll

#### Постановка задачи
Провести анализ живых и мертвых переменных внутри отдельного базового блока. Произвести удаление мертвых переменных, в т.ч. каскадное.

#### Зависимости задач в графе задач

Задача зависит от:
* Генерация трехадресного кода
* Выделение базовых блоков

От задачи зависит:
* Удаление мертвых переменных на основе итерационного алгоритма

#### Теория
Если некоторая переменная, определенная в точке c1 до точки использования c2 не переопределяется, то такая переменная называется живой или активной, иначе - мертвой. Анализ определения живых и мертвых переменных в пределах блока осуществляется снизу-вверх, т.е. от последней команды блока к первой. В данной оптимизации используется консервативное предположение о том, что все, кроме временных, переменные при выходе из блока являются живыми. Каскадное удаление устраняет код, который становится мертвым только при удалении другого мертвого кода.


#### Особенности реализации
Для использования данной оптимизации необходимо:
1. Подключить пространство имен using SimpleLang.ThreeCodeOptimisations;
2. Построить граф потоков управления
3. Применить оптимизацию к каждому из блоков

Ниже представлен код использования данной оптимизации:
```csharp
// граф потоков управления controlFlowGraph уже построен
foreach (var block in controlFlowGraph.blocks)
{
		var replace = DeadOrAliveOptimization.DeleteDeadVariables(block);
		block.Clear();
		foreach (var line in replace)
		block.AddLast(line);
}
```
Так как метод DeleteDeadVariables не изменяет исходный блок, а возвращает новый, то каждый блок исходного графа нужно заменять на оптимизированный. Для упрощения выполнения данной оптимизации в классе DeadOrAliveOptimization реализован метод, который выполняет эту оптимизацию для всего переданного графа и возвращает новый граф:
```csharp
controlFlowGraph = DeadOrAliveOptimization.DeleteDeadVariables(controlFlowGraph);
```
В представленном классе статические методы позволяют произвести каскадное удаление мертвого кода в пределах одного блока. Метод, принимающий лишь информацию о трехадресном коде блока использует консервативное предположение о том, что любое из определений может быть использовано в последующих блоках. Поэтому все определения в конце блока считаются активными.
Другая версия метода принимает предварительно вычисленную информацию об активных переменных. Это необходимо для последующей задачи глобальной оптимизации удаления мертвого кода на основе итерационного алгоритма для активных переменных.

#### Тесты
``` csharp
Исходный код программы
{
    int a,b,c;
    c = 400;
    a = 500;
    b = 200;
    while ((c > (a - b)))
    {
        c = (c + 1);
        a = b;
        b = 100;
        b = (c + 4);
        a = 30;
    }
}
Блоки трехадресного кода до каскадного удаления мертвых переменных
           c = 400
           a = 500
           b = 200
label_0:   temp_2 = a - b
           temp_1 = c > temp_2
           temp_0 = temp_1
           if temp_0 goto label_1
           goto label_2
label_1:   c = c + 1
           a = b
           b = 100
           b = c + 4
           a = 30
           goto label_0
label_2:


Блоки трехадресного кода после удаления мертвых переменных
           c = 400
           a = 500
           b = 200
label_0:   temp_2 = a - b
           temp_1 = c > temp_2
           temp_0 = temp_1
           if temp_0 goto label_1
           goto label_2
label_1:   c = c + 1
           b = c + 4
           a = 30
           goto label_0
label_2:
```
[Вверх](#содержание)