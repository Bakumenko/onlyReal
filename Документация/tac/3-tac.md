# Свертка констант, протяжка констант, оптимизация алгебраических тождеств внутри базового блока !heading

### Команда Roslyn

## Свертка констант !heading

#### Постановка задачи
Требуется найти в трехадресном коде выражения, в которых участвуют только константные значения и произвести вычисления найденных выражений на этапе компиляции исходного кода программы.

#### Зависимости задач в графе задач
Задача зависит от:
* генерации трехадресного кода.

#### Теория
В исходном программном коде часто встречаются выражения, в которых принимают участие только константные значения. Примером такого выражения может служить следующий код:
```cpp
int val = 1234 + 4321 - 5555 * (8888/4444 - 1);
bool b = (val < 1) && (true || false) && (3.14 < (val + 4));
```
Подобные выражения можно оптимизировать, если произвести вычисления на этапе компиляции исходного программного кода. Это позволит сделать вычисление программы более быстрым, поскольку все выражения, в которых принимают участие только константы, будут вычислены до запуска программы.

#### Особенности реализации
При использовании кода, производящего оптимизацию свертки констант, следует использовать класс, реализующий каскадные оптимизации трехадресного кода программы AutoThreeCodeOptimiser. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать трехадресный код;
2) создать объект *SimpleLang.ThreeCodeOptimisations.AutoThreeCodeOptimiser*;
3) добавить к созданному объекту новый объект типа *SimpleLang.ThreeCodeOptimisations.EvalConstExpr*;
4) вызвать метод Apply объекта AutoThreeCodeOptimiser.
```csharp
using SimpleLang.ThreeCodeOptimisations;
...
AutoThreeCodeOptimiser opt = new AutoThreeCodeOptimiser();
opt.Add(new EvalConstExpr());
opt.Apply(visitor);
```
В данном коде подразумевается, что переменная *visitor* является объектом класса *ThreeAddressCodeVisitor*.


#### Тесты
Для исходного кода 
```csharp
{
	int val;
	val = 1234 + 4321 - 5555 * (8888/4444 - 1);
	bool b;
	b = (val < 1) && (true || false) && (3.14 < (val + 4));
}
```
генератор трехадресного кода генерирует следующий код:
```csharp
    temp_1 = 1234 + 4321
    temp_4 = 8888 / 4444
    temp_3 = temp_4 - 1
    temp_2 = 5555 * temp_3
    temp_0 = temp_1 - temp_2
    val = temp_0
    temp_7 = val < 1
    temp_8 = True || False
    temp_6 = temp_7 && temp_8
    temp_10 = val + 4
    temp_9 = 3.14 < temp_10
    temp_5 = temp_6 && temp_9
    b = temp_5
```
После использования оптимизации свертки констант получается следующий код:
```csharp
    temp_1 = 5555
    temp_4 = 2
    temp_3 = temp_4 - 1
    temp_2 = 5555 * temp_3
    temp_0 = temp_1 - temp_2
    val = temp_0
    temp_7 = val < 1
    temp_8 = True
    temp_6 = temp_7 && temp_8
    temp_10 = val + 4
    temp_9 = 3.14 < temp_10
    temp_5 = temp_6 && temp_9
    b = temp_5
```

Если к выше представленному программному коду, написанном на реализованном языке программирования применить каскадно следующие оптимизации:
* свертка констант;
* распространение констант внутри базового блока;
* живые или мертвые переменные,
то получится с оптимизировать код до следующего:
```csharp
    val = 0
    b = True
```

## Протяжка констант  !heading

#### Постановка задачи
Требуется найти внутри базового блока переменные, имеющих константное значение, и заменить имена переменных во всех выражениях внутри данного базового блока, использующих данные переменные, их значениями.

#### Зависимости задач в графе задач
Задача зависит от:
* генерации трехадресного кода.

#### Теория
В исходном  коде программ часто встречаются выражения, которые содержат использование переменных, имеющих константное значение. Примером такого кода может  служить код, приведенный ниже:
```cpp
double pi = 3.14;
double r = 5.67;
double S = pi * r * r;
```
Подобные выражения можно оптимизировать, если при компиляции исходного кода программы произвести подстановку значений константных переменных по всему коду за местом присваивания данной переменной. Это позволит сделать вычисление программы более быстрым, поскольку потребуется меньше памяти для вычисления программы, поскольку некоторые переменные перестанут быть необходимыми, и операций работы с оперативной памятью станет меньше.

#### Особенности реализации
При использовании кода, производящего оптимизацию протяжки констант внутри базового блока, следует использовать класс, реализующий каскадные оптимизации трехадресного кода программы AutoThreeCodeOptimiser. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать трехадресный код;
2) создать объект *SimpleLang.ThreeCodeOptimisations.AutoThreeCodeOptimiser*;
3) добавить к созданному объекту новый объект типа *SimpleLang.ThreeCodeOptimisations.DistributionOfConstants*;
4) вызвать метод Apply объекта AutoThreeCodeOptimiser.
```csharp
using SimpleLang.ThreeCodeOptimisations;
...
AutoThreeCodeOptimiser opt = new AutoThreeCodeOptimiser();
opt.Add(new DistributionOfConstants());
opt.Apply(visitor);
```
В данном коде подразумевается, что переменная *visitor* является объектом класса *ThreeAddressCodeVisitor*.


#### Тесты
Для исходного кода 
```csharp
{
	real a;
	a = 67.0;
	real b;
	b = 13.0;
	real c;
	c = a - b + (a/b + b/a - (a/a) * (b/b));
}
```
генератор трехадресного кода генерирует следующий код:
```csharp
    a = 67
    b = 13
    temp_1 = a - b
    temp_4 = a / b
    temp_5 = b / a
    temp_3 = temp_4 + temp_5
    temp_7 = a / a
    temp_8 = b / b
    temp_6 = temp_7 * temp_8
    temp_2 = temp_3 - temp_6
    temp_0 = temp_1 + temp_2
    c = temp_0
```
После использования оптимизации свертки констант получается следующий код:
```csharp
    a = 67
    b = 13
    temp_1 = 67 - 13
    temp_4 = 67 / 13
    temp_5 = 13 / 67
    temp_3 = temp_4 + temp_5
    temp_7 = 67 / 67
    temp_8 = 13 / 13
    temp_6 = temp_7 * temp_8
    temp_2 = temp_3 - temp_6
    temp_0 = temp_1 + temp_2
    c = temp_0
```

Если к выше представленному программному коду, написанном на реализованном языке программирования применить каскадно следующие оптимизации:
* свертка констант;
* распространение констант внутри базового блока;
* живые или мертвые переменные,
то получится с оптимизировать код до следующего:
```csharp
    a = 67
    b = 13
    c = 58.3478760045924
```

## Оптимизация алгебраических тождеств !heading

#### Постановка задачи
Требуется найти в трехадресном коде выражения, результаты которых можно вычислить на этапе компиляции в не зависимости от значений переменных, участвующих в выражении, и произвести соответствующие оптимизации, заменив выражения их значениями.

#### Зависимости задач в графе задач
Задача зависит от:
* генерации трехадресного кода.

#### Теория
В исходном коде программы можно встретить выражения, результат которых можно вычислить на этапе компиляции проекта в не зависимости от конкретных значений переменных. К таким выражениям можно отнести следующие:

* *b\*0*
* *1\*b*
* *b\*1*
* *b+0*
* *0+b*
* *b-1*
* *b-b*
* *b/1*

Подобные выражения можно оптимизировать, если при компиляции исходного кода программы частично произвести вычисления данных выражений. В некоторых ситуациях можно получить конечный результат выражения, но в некоторых случаях необходимо знать значения конечных переменных. Подобная оптимизация позволит сделать вычисление программы более быстрым, поскольку потребуется меньше памяти для вычисления программы, поскольку некоторые переменные перестанут быть необходимыми, и операций работы с оперативной памятью станет меньше.

#### Особенности реализации
При использовании кода, производящего оптимизацию вычисления алгебраических выражений, следует использовать класс, реализующий каскадные оптимизации трехадресного кода программы AutoThreeCodeOptimiser. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать трехадресный код;
2) создать объект *SimpleLang.ThreeCodeOptimisations.AutoThreeCodeOptimiser*;
3) добавить к созданному объекту новый объект типа *SimpleLang.ThreeCodeOptimisations.ApplyAlgebraicIdentities*;
4) вызвать метод Apply объекта AutoThreeCodeOptimiser.
```csharp
using SimpleLang.ThreeCodeOptimisations;
...
AutoThreeCodeOptimiser opt = new AutoThreeCodeOptimiser();
opt.Add(new ApplyAlgebraicIdentities());
opt.Apply(visitor);
```
В данном коде подразумевается, что переменная *visitor* является объектом класса *ThreeAddressCodeVisitor*.


#### Тесты
Для исходного кода 
```csharp
{
	int b;
	b = b * 0;
	b = 1 * b;
	b = b * 1;
	b = b + 0;
	b = 0 + b;
	b = b - 0;
	b = b - b;
	b = b / 1;
}
```
генератор трехадресного кода генерирует следующий код:
```csharp
    temp_0 = b * 0
    b = temp_0
    temp_1 = 1 * b
    b = temp_1
    temp_2 = b * 1
    b = temp_2
    temp_3 = b + 0
    b = temp_3
    temp_4 = 0 + b
    b = temp_4
    temp_5 = b - 0
    b = temp_5
    temp_6 = b - b
    b = temp_6
    temp_7 = b / 1
    b = temp_7
```
После использования оптимизации алгебраических тождеств получается следующий код:
```csharp
    temp_0 = 0
    b = temp_0
    temp_1 = b
    b = temp_1
    temp_2 = b
    b = temp_2
    temp_3 = b
    b = temp_3
    temp_4 = b
    b = temp_4
    temp_5 = b
    b = temp_5
    temp_6 = 0
    b = temp_6
    temp_7 = b
    b = temp_7
```
[Вверх](#содержание)
