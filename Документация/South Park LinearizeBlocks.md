# Оптимизация по дереву: все блоки, вложенные в блоки, сделать линейными
(Оптимизации по дереву: все блоки, вложенные в блоки, сделать линейными)

### South Park

#### Постановка задачи

Задача состояла в реализации оптимизации AST-дерева следующего вида: все блоки, вложенные в блоки, сделать линейными

#### Зависимости задач в графе задач

Данная задача не зависит от других задач в графе задач и не порождает новых зависимостей.

#### Теория
Если один блок оказывается вложен в другой и при этом внутренний блок не относится ни к какому оператору, его можно линеаризовать.

#### Особенности реализации

```csharp
    class LinearizeBlocks : AutoApplyVisitorInterface
    {
        public override void VisitBlockNode(BlockNode bl)
        {
            for (int i = 0; i < bl.StList.Count; i++)
            {
                if (bl.StList[i] is BlockNode)
                {
                    BlockNode bl1= (BlockNode)bl.StList[i];

                    bl.StList.RemoveAt(i);
                    for (int j = 0; j < bl1.StList.Count; j++)
                    {
                        bl.StList.Insert(i+j, bl1.StList[j]);
                    }
                }
                bl.StList[i].Visit(this);
            }    
        }
    }
```
Класс _LinearizeBlocks_ является визитором и реализует интерфейс _AutoApplyVisitorInterface_. При посещении узла типа блок функция проходит по всем его инструкциям и, если какая-то инструкция является блоком, то это вложенный блок. Чтобы его линеаризовать, список инструкций блока сохраняется в переменную типа блок, далее алгоритм удаляет вложенный блок. После этого алгоритм заменяет удаленный вложенный блок его инструкциями. После этой процедуры обход дерева продолжается в обычном режиме.

#### Тесты
Пример входной программы:
```
{
	real b;
	int c;
	b=3.14;
	{
		c = 0;
	}	
}
```
Пример программы после применения оптимизации:
```
{
	var b;
	var c;
	b = 3.14;
	c = 0;
}
```


