### Оптимизация '<' и '>' в AST-дереве
Оптимизация AST-дерева. Оптимизация операторов сравнения.

### Команда GreatBean

#### Постановка задачи
Требуется найти в AST-дереве операторы сравнения, оба операнда которого являются числами на этапе компиляции и заменить их на логическое утверждение этих операторов.

#### Зависимости задач в графе задач
Задача зависит от:
* генерация AST-дерева;
* заполнение связей типа "предок-потомок".

#### Теория
В исходном коде программы зачастую появляются случаи, когда уже на этапе компиляции ясно, какие значения приняли те или иные перменные, являющиейся операндами в оператора сравнения. Преждевременая замена таких операторов на логические выражения, соответствующие смыслу этих опраторов может заметно ускорить программу на этапе выполнения.


#### Особенности реализации
При использовании программного кода, позволяющего произвести оптимизацию операторов сравнения, требуется произвести построение AST-дерева для исходного кода программы, написанном на реализованном языке программирования, и выделить для построенного дерева связи типа "предок-потомок".
К полученному дереву следует применить визитор SimpleLang.Visitors.LessOptVisitor. Таким образом, последовательность действий для использования данной оптимизации будет следующей:
1) сгенерировать AST-дерево;
2) с помощью визитора SimpleLang.Visitors.FillParentVisitor заполнить связи между узлами дерева типа "предок-потомок";
3) создать объект типа SimpleLang.Visitors.LessOptVisitor;
4) для полученного дерева вызвать функцию Visit с объектом LessOptVisitor, созданном на 3-ем этапе, поданным как аргумент функции.

Для решения этой задачи был реализован класс LessOptVisitor, который переопределяет класс VisitLogicOpNode. Стоит отметить, что перед заменой оператора сравнения на его логическое значение необходимо заранее обойти каждого из операндов для рекурсивной проверки их на возможность такой-же оптимизации.
Важно понимать, что оптимизации просиходит только в случае принадлежности обоих операндов численному типу.
```csharp
public class LessOptVisitor : ChangeVisitor
{
    public override void VisitLogicOpNode(LogicOpNode lop)
    {
        if (lop.Left is ExprNode)
            lop.Left.Visit(this); // Вначале сделать то же в левом поддереве

        if (lop.Right is ExprNode)
            lop.Right.Visit(this); // Затем в правом поддереве

        if (lop.Left is IntNumNode l && lop.Right is IntNumNode r
            && (lop.Operation == ">" || lop.Operation == "<"))
        {
            //Посчитаем сам знак
            bool nbool = lop.Operation == ">" ? l.Num > r.Num : l.Num < r.Num;
            //Проверим, что выражение не является условиев if
            if (lop.Parent is IfNode ifn)
                ifn.Cond = new BooleanNode(nbool);
            //Проверим, что выражение не является условиев while
            else if (lop.Parent is WhileNode w)
                w.Expr = new BooleanNode(nbool);
            else
                ReplaceExpr(lop, new BooleanNode(nbool));
        }
        else // Если оптимизаций нет, то
        {
            base.VisitLogicOpNode(lop); // Обойти потомков обычным образом
        }
    }

}
```


#### Тесты
Из исходной программы вида
```csharp
{
	bool w;
	w = (1 > 2) && (4 < 77);
}
```

Мы получаем
```csharp
{
    var w;
    w = (false && true);
}
```
